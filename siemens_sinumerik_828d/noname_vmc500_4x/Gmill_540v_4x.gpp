; General Post Processor
; Machine           :
; Type              :
; SubRoutines       :
; Comp Type         : 
; Customer          : 
; Rev 1.0 :10.23.2012 : Configured post for evaluation version software.
; ---Things to do-----
;
@init_post

    global string sUS_date sUS_time sUsrmsg sHomestr sHomestrbegin sHomestrtc sHomestrend sHomestrstpdiff sHomestrstpsame sHomeline sHomestrendsub
    global string sCamfilepath sSubspath cWo cPb cPe cG84 cG84p cCycs cHomep cTCcodep cTCcodes fG84spin cDr cCb cCe cOMb cOMe sWorkoffset
    global logical bStartFile bTlchg bTraceUsrcall bSkipxyrapid bWorkoffsettc bFirstMove bFirstMovetlch bFirstRapid
    global logical bSubs bTlist bTlseperation bTcseperation bDateTimeOutput bStopM00difftool bToolPreselect bToolChangeAtEnd
    global logical bFromendprogram bFrombeginchangetool bFromendchangetool bFromendoffile bMultiplefixtures
    global logical bSafetyprep bSyncdrapid bFeedoutput bNnumtc bskipline bVertical bFirstVert
    global logical bOptstpbegin bOptstptc bOptstpend bUseprognum bUseprogname bCoolspinaftertc
    global logical bCoolExist bCoolofftc bSpinofftc bCooloffend bSpinoffend bG84spin bPrintloop bTest
    global integer iMplane iAbsincmode iWorkoffset iHeightcomp iStopmode iMotionmode iPworkoffset
    global integer iDiametercomp iDrillmode iTcnumber iNumpecks iSpindleDir
    global integer iSlength_g_file_name iSlength_full_g_file_name iSlengthcampartpath iDiameteroffset iArcmode
    global integer iHomingmode iWorkOffsetmode iProgendmode iG187_P_gpp iPal1 iPal2
    global integer iCoolantM1 iCoolantM2 iCoolantM3 iCoolantM4 iCoolantM5 iCoolantM6 iCoolantM7 iCoolantM8
    global integer iCoolantM1ON iCoolantM2ON iCoolantM3ON iCoolantM4ON iCoolantM5ON iCoolantM6ON iCoolantM7ON iCoolantM8ON
    global integer iCoolantM1OFF iCoolantM2OFF iCoolantM3OFF iCoolantM4OFF iCoolantM5OFF iCoolantM6OFF iCoolantM7OFF iCoolantM8OFF
    global numeric nTcXnext nTcYnext nTcZnext nTcCnext nCorrectedpeck nRapidfeed nG187_E_gpp nR_value

    global numeric nR1pos nR1pos5x nR1postmatrix nR1postransform nR1poscpos iR1dir nPR1pos nR1posadj nR1postemp nPR1postemp nR1pdir
    global numeric nR2pos nR2pos5x nR2postmatrix nR2postransform nR2poscpos iR2dir nPR2pos nR2posadj nR2postemp
    global numeric nPtool_start_plane prevFeed nLlabel nPtool_z_level
    global string  cR1 cR2 sHomestrrot sHomestrrotv sHomestrroth nR1pos_f nR2pos_f bpos_f ;apos_f
    global integer iFeedType iR1posControl i4xIndexMode i4xIndexClearanceMode i4xFeedMode
    global integer iGear1 iGear2 iGear3 iGear4 iGear iFirst_tool
    global integer var1 var2 Var3 var4 var5 Var6 macnum ORGXYZ P_Offset
    global numeric newshift_z newshift_y  newshift_x newshift_b
    global string shift_x_sign shift_y_sign shift_z_sign shift_b_sign newshift_z_f newshift_y_f  newshift_x_f P_Dwell_f
	global numeric last_spin spindle_accel

    ; Non GPPL variables
	last_spin = 0
	spindle_accel = 500 ; rpm/s
	
    num_user_procs =    1
    remove_blanks = FALSE
    line_labels    = FALSE     ; Jump to N...
    clear_change_after_gen = 1

    ; GPPL variables
    numeric_def_f   = '5.4'
    integer_def_f   = '5.0(p)'
    gcode_f         = '2.0(p)'
    mcode_f         = '2.0(p)'
    xpos_f          = '5.4'
    ypos_f          = '5.4'
    zpos_f          = '5.4'
    nR1pos_f        = '<(>5.3<)>'
    apos_f          = '5.3'
    bpos_f          = '5.3'
    feed_f          = '4.4(P)'
    P_Dwell_f       = '4.4(P)'
    newshift_z_f    = '+5.4'
    newshift_y_f    = '+5.4'
    newshift_x_f    = '+5.4'
    blknum_f        = '5.0(p)'
    blknum_gen      = true
    call @usr_ip_useroptions
    call @usr_ip_postwriteroptions
endp

@usr_ip_useroptions
    ; Handle setting of options -- For users
    ;Machine Definition
    bToolPreselect        = TRUE                ;True = Next tool is Preselected after tool change
    bSyncdrapid           = TRUE                ;True = Machine Sync's Rapid Motion (Non-Box Move)
    nRapidfeed            = 650.                ;Set your value for Max Feed in G1 (Used with Non-Sync'd Rapid Moves)
    bUseprognum           = false               ;True = Outputs Program Number
    bUseprogname          = TRUE                ;True = Outputs Program Name
    iArcmode              = 2                   ;Sets Arc Output Mode (1=AbsIJK, 2=IncIJK, 3=R 360AbsIJK, 4=R 360IncIJK)
    cTCcodep              = 'M06 '             ;Sets the Prefix Code(s) used for Tool Change (i.e. 'M06')
    cTCcodes              = ''                  ;Sets the Suffix Code(s) used for Tool Change (i.e. 'M06')
    cWo                   = 'G'                 ;Sets the Character(s) used for Work Offset (i.e. G,E,G54.1 P)
    iWorkOffsetmode       = 1                   ;Sets the Mode used for Work Offset (1=G54, 2=E1, 3=G54.1 P1)
    iProgendmode          = 1                   ;Sets the code for ending a program (1=M30,2=M2)
    cPb                   = ';%_N_'              ;Sets the Character(s) used for the beginning of file (i.e %)
    cPe                   = ''                 ;Sets the Character(s) used for the beginning of file (i.e %)
    cCb                   = ';'                 ;Sets the begginning Character(s) for comments
    cCe                   = ''                  ;Sets the ending Character(s) for comments
    cOMb                   = 'MSG("'            ;Sets the begginning Character(s) for operator message
    cOMe                   = '")'               ;Sets the ending Character(s) for operator message
    cDr                   = ''                  ;Sets the Character(s) used at the begging of a drill cycle (i.e. G98,G98,or nothing '')
    cG84                  = ''                  ;Sets the Drill Cycle Character(s) used tapping (i.e. G84, G84.1)
    cG84p                 = ''                  ;Sets the Preperation Line used for G84 Tapping (i.e. G84.2)**FADAL setting
    bG84spin              = false               ;True = RPM is output during G84 Tapping Cycles
    fG84spin              = '5.1'               ;Sets Formatting for RPM used for G84 Tapping Cycles ('5.1' = Decimal point 1 place)
    cCycs                 = 'L0 '               ;Sets the Suppression Code to ignore Drill Cycles (i.e. LO)

    ;Coolant & Spindle Control
	flood_coolant               = 1
    bCoolExist					= true          ;True = Outputs Coolant codes (Coolant,Air,Mist,etc)
    bCoolofftc					= true          ;True = Outputs Coolant off between Tool Changes
    bSpinofftc					= true          ;True = Outputs Spindle off between Tool Changes
    bCooloffend					= true          ;True = Outputs Coolant off at end of program
    bSpinoffend					= true          ;True = Outputs Spindle off at end of program
    bCoolspinaftertc			= false         ;True = Outputs Coolant&Spindle directly after Tool Change
    iGear1						= 41            ;Code: M code for low spindle gear
    iGear2						= 42            ;Code: M code for low spindle gear
    iGear3						= 43            ;Code: M code for low spindle gear
    iGear4						= 44            ;Code: M code for low spindle gear
    iCoolantM1ON				= 8             ;Code: Flood Coolant ON
    iCoolantM1OFF				= 9             ;Code: Flood Coolant OFF
    iCoolantM2ON				= 7             ;Code: Mist Coolant ON
    iCoolantM2OFF				= 9             ;Code: Mist Coolant OFF
    iCoolantM3ON				= 130           ;Code: HP-Flood Coolant ON
    iCoolantM3OFF				= 9             ;Code: HP-Flood Coolant OFF
    iCoolantM4ON				= 8             ;Code: LP-Flood Coolant ON
    iCoolantM4OFF				= 9             ;Code: LP-Flood Coolant OFF
    iCoolantM5ON				= 77           ;Code: High Pressure Coolant Through Tool ON
    iCoolantM5OFF				= 9             ;Code: High Pressure Coolant Through Tool OFF
    iCoolantM6ON				= 51            ;Code: Low Pressure Coolant Through Tool ON
    iCoolantM6OFF				= 9             ;Code: Low Pressure Coolant Through Tool OFF
    iCoolantM7ON				= 50            ;Code: Air Blast ON
    iCoolantM7OFF				= 9             ;Code: Air Blast OFF
    iCoolantM8ON				= 92            ;Code: Air Through Tool ON
    iCoolantM8OFF				= 9             ;Code: Air Through Tool OFF
    iPal1						= 911           ;code: pallet in
    iPal2						= 912           ;code: pallet in

    ;User Preferences
    bTlist						= true          ;True = Outputs tool list at beginning of program
    bTlseperation				= false         ;True = Seperates Tool List by blank line(s)
    bTcseperation				= false         ;True = Seperates Tool List by blank line(s)
    bDateTimeOutput             = true          ;True = Outputs Date & Time
    bToolChangeAtEnd			= false         ;True = Tool Change for First Tool at end of program
    bOptstpbegin				= false         ;True = Outputs Optional Stop at beginning of program
    bOptstptc					= true          ;True = Outputs Optional Stop between Tool Changes
    bOptstpend					= false         ;True = Outputs Optional Stop at end of program
    bWorkoffsettc				= true          ;True = Forces output of Work Offset at each Tool Change
    bNnumtc						= False         ;True = Outputs N Numbers at Tool Changes (i.e. N1,N2,N3)
    blknum_exist				= False         ;True = Outputs Line Numbers
    blknum						= 200           ;Sets Starting Line Number
    blknum_delta				= 10            ;Sets the delta for Line Numbers
    blknum_max					= 99999         ;Sets the maximum value for Line Numbers

    ;Homing Format Definitions
    ;[integer:][Prepstr :][AxisStr1 ;][AxisStrN]
    ;integer = Homing Output Mode (1=G28, 2=G28 G91, 3=G53 Non-Modal, 4=G53 Modal, 5=G30, 6=G30 G91 7=G90 G54 8= ANY STRING)
    ;PrepStr = Sets the code(s) for the begging of line used for Homing Axis (i.e. 'G00')
    ;AxisStr = Homing Axis Definition (i.e. 'Z0.0', 'H0.0 W0.')
    ;Note: You can define up to 49 "Homing Lines" seperated by ";"
    ;Note: Only use ";" if using more then 1 "Homing Line"
    ;Note: Define string as empty '' to ignore Specific Homing Definition
    sHomestrbegin         = '8::G75 Z1=0. ;8::G75 Y1=0 X1=0'                           ; Program Begin Homing Definition
    sHomestrtc            = '8::G75 Z1=0. ;8::G75 Y1=0 X1=0'                           ; Tool Change Homing Definition
    sHomestrend           = '8::G75 Z1=0. '                     ; Program End Homing Definition
    sHomestrendsub        = ''                     ; Program End Homing Definition
    sHomestrstpsame       = ''                 ; M00 Same Tool Homing Definition
    sHomestrstpdiff       = ''      ; M00 Different Tool Homing Definition
    sHomestrrotv           = '8::G75 Z1=0. ;8::G75 Y1=0 X1=0'                     ;Between Rotations
    sHomestrroth           = '8::G75 Z1=0. ;8::G75 Y1=0 X1=0'                     ;Between Rotations

    ; ---- 4x
    iR1dir                = -1         ;Rotary 1 direction 1=+CCW -1=+CW
    iR2dir                = 1         ;Rotary 2 direction 1=+CCW -1=+CW
    cR1                   = 'A=DC'       ;Rotary 1 Axis
    cR2                   = 'B'       ;Rotary 2 Axis
    iR1posControl         = 1         ;Rotary Position Control (0=SolidCAM Direct, 1=Positive, 2=Negative, 3=Shortest Distance)
    i4xIndexMode          = 1         ;4x-Indexing control (0=Simple Rotation, 1=New WorkOffset, 2=Trig Macro)
    i4xIndexClearanceMode = 3         ;4x-Index Clearance control (0=Z-Homing, 1=Z-Tool_Z_Level, 2=Z-Tool_start_plane)
    i4xFeedMode           = 1         ;4x-Simultanious control (0=Programed feedRate, 1=Inverse Time FeedRate, 2=Deg. per Minute)
    ; ---- 4x

endp

@usr_ip_postwriteroptions
    ; Handle setting of options -- For Post Writers
    bSubs = false          ;True = Using sub routines, False = Not using sub routines
    ; ------Below are tracing functions-----
    ; trace "all":5
    ; trace "@tmatrix":5
    ; trace "@def_tool":5
    ; trace "@drill_point":5
endp

;-------------------

@start_of_file
    ; Handle what is output at the start of the file
    ; This is the first procedure called (lie...@init_post is actually first)
    if iNumber_of_Fixtures > 1
        bMultiplefixtures = true
        blknum_exist    = false
    endif
    call @usr_campart_path
    call @usr_init_gmstates
    call @usr_sof_character
    call @usr_sof_progname
    call @usr_sof_commentsbeforecodes
    call @usr_sof_gmcodes
    call @usr_sof_commentsaftercodes
    bStartFile = true
    if message1 ne ''
        {NL, cCb message1 cCe }
    endif
    if message2 ne ''
        {NL, cCb message2 cCe }
    endif
    if message3 ne ''
        {NL, cCb message3 cCe }
    endif
    if message4 ne ''
        {NL, cCb message4 cCe }
    endif
    if message5 ne ''
        {NL, cCb message5 cCe }
    endif
    if message6 ne ''
        {NL, cCb message6 cCe }
    endif
    if message7 ne ''
        {NL, cCb message7 cCe }
    endif
    if message8 ne ''
        {NL, cCb message8 cCe }
    endif
    if message9 ne ''
        {NL, cCb message9 cCe }
    endif
    if message10 ne ''
        {NL, cCb message10 cCe }
    endif
endp

@usr_sof_character
    ; Handle start of file character
    {,cPb}
endp

@usr_sof_progname
    ; Handle Program Number and/or Name
    Local Integer name1 name2
    Local string part_name1 part_name2
    name1 = strlen(part_name)
    name2 = instr(part_name,'-')
    while name2 gt 0
        name2 = instr(part_name,'-')
        if name2 gt 0
            part_name = left(part_name,(name2-1)) + '_' + right(part_name,(name1-name2))
        endif
    endw
    if bUseprognum
        {nl, 'O'(program_number)}
        if bUseprogname
            {nl,cCb, part_name,cCe}
        endif
    else
        if bUseprogname
;			part_name = left(g_file_name,6)
;			part_name = left(g_file_name,(instr(g_file_name,'.') - 1))
            {part_name'_MPF' }
            if strlen(sWorkpcDir) eq 0
                {nl,cCb, '$PATH=/_N_WKS_DIR/_N_WPD'  ,cCe}
            else
                {nl,cCb, '$PATH=/_N_WKS_DIR/_N_'sWorkpcDir '_WPD' ,cCe}
            endif
        endif
    endif
endp

@usr_sof_commentsbeforecodes
    ; Handle HardCoded or PartControlled comments  (Before G/M codes)
    ;{nl,cCb'COMPENSATION-WEAR'cCe}
    call @usr_US_date
    call @usr_US_time
    if bDateTimeOutput
        {nl,cCb,sUS_date'-'sUS_time,cCe}
    endif
endp

@usr_sof_gmcodes
    ; Handle HardCoded or PartControlled G/M codes
endp

@usr_sof_commentsaftercodes
    ; Handle HardCoded or UserDefined comments (After G/M codes)
    if bTlseperation
        {nl}
        {nl}
        {nl}
    endif
endp

@usr_US_date
    ; Converts Europe Date format to US format
    Local Integer iInt1
    iInt1 = instr(date,'-')
    sUS_date = substr(date,(iInt1+1),3) + '-' + substr(date,1,(iInt1-1)) + '-' + right(date,4)
endp

@usr_US_time
    ; Converts Military time to 12hr format
    Local Integer iInt1 iHr_Mil_int iHour
    Local String iHr_Mil iTm_of_day
    iInt1 = instr(time,':')
    iHr_Mil = left(time,(iInt1-1))
    iHr_Mil_int = tonum(iHr_Mil)
    if iHr_Mil_int < 12
        if iHr_Mil_int < 1
            iHour = 12
        else
            iHour = iHr_Mil_int
        endif
        iTm_of_day = 'AM'
    else
        if iHr_Mil_int < 13
            iHour = 12
        else
            iHour = iHr_Mil_int - 12
        endif
        iTm_of_day = 'PM'
    endif
    sUS_time = tostr(iHour:'5.0(p)') + substr(time,iInt1,8) + iTm_of_day
endp

@usr_init_gmstates
    ; Handle initializing G/M codes for correct modality from beginning of file
    nLlabel         = 0
    iMplane         = 17
    iAbsincmode     = 90
    iWorkoffset     = 9999
;	iHeightcomp     = 9999
    iMotionmode     = 0
    iDiametercomp   = 9999
;	iDiameteroffset = 9999
    iDrillmode      = 9999
    iTcnumber       = 2001
    iCoolantM1      = iCoolantM1OFF
    iCoolantM2      = iCoolantM2OFF
    iCoolantM3      = iCoolantM3OFF
    iCoolantM4      = iCoolantM4OFF
    iCoolantM5      = iCoolantM5OFF
    iCoolantM6      = iCoolantM6OFF
    iCoolantM7      = iCoolantM7OFF
    iCoolantM8      = iCoolantM8OFF
    iG187_P_gpp     = 2
    nG187_E_gpp     = 0
    ; ---- 4x
    nR1pos          = 9999
    nPR1pos			 = 0
    nPR1postemp     = 0
    change(cWo)		 = false
    change(cR2)		 = false
    change(cR1)		 = false
    bFirstVert      = true
    ; ---- 4x
endp

;-------------------

@def_tool
    ; Handle Tool List Output at top of program
    ; Use bTlchg to use different message for tool_change
    if bTlist
        if tool_message == '' then
            {nl, cCb'TOOL 'tool_number, ' - DIA '(tool_offset*2),cCe }
        else
            {nl,cCb'T'tool_number,'-' tool_message,cCe}
            if msg_mill_tool1 ne ''
                {nl,cCb'---' msg_mill_tool1,cCe}
            endif
            if msg_mill_tool2 ne ''
                {nl,cCb'---' msg_mill_tool2,cCe}
            endif
            if msg_mill_tool3 ne ''
                {nl,cCb'---' msg_mill_tool3,cCe}
            endif
            if msg_mill_tool4 ne ''
                {nl,cCb'---' msg_mill_tool4,cCe}
            endif
            if msg_mill_tool5 ne ''
                {nl,cCb'---' msg_mill_tool5,cCe}
            endif
        endif
        if next_command ne '@def_tool' and bTlchg eq false
            if bTlseperation
                {nl}
                {nl}
                {nl}
            endif
            if bOptstpbegin
                call @usr_optionalstop
            endif
            {nl, 'MSG(" Loading Zeropoints ")'}
        endif
    endif
endp

;-------------------

@start_program
    ; Handle any safety G/M codes for top of program
    if sHomestrbegin ne ''
        sHomestr = sHomestrbegin
        call @usr_prep_home_axis
    endif
endp

;-------------------

@end_program
    ; Handle output for end of program
    change(iWorkoffset) = false
    if bMultiplefixtures eq True
        bFromendprogram = True
        call @Multiple_Fixtures
    endif
    if bCooloffend and bCoolExist
        iCoolantM1 = iCoolantM1OFF
        iCoolantM2 = iCoolantM2OFF
        iCoolantM3 = iCoolantM3OFF
        iCoolantM4 = iCoolantM4OFF
        iCoolantM5 = iCoolantM5OFF
        iCoolantM6 = iCoolantM6OFF
        iCoolantM7 = iCoolantM7OFF
        iCoolantM8 = iCoolantM8OFF
        change(iCoolantM1) = true
        change(iCoolantM2) = false
        change(iCoolantM3) = false
        change(iCoolantM4) = false
        change(iCoolantM5) = false
        change(iCoolantM6) = false
        change(iCoolantM7) = false
        change(iCoolantM8) = false
        bskipline = true
        call @usr_coolant_output
    endif
    if bSpinoffend
        iSpindleDir = 5
        {nb}
        call @usr_spindle_mcode_output
    endif
    if sHomestrend ne ''
        sHomestr = sHomestrend
        call @usr_prep_home_axis
    endif
    change(iAbsincmode) = false
    if change(iAbsincmode)
        {nb}
        call @usr_abs_inc_output
    endif
    if change(iWorkoffset)
        {nb}
        call @usr_homenumber_output
    endif
    if bOptstpend
        call @usr_optionalstop
    endif
    if bToolChangeAtEnd
        {nb,cTCcodep'T'next_tool_number' 'cTCcodes}
    endif
    if bVertical
;        {nb, 'HVH'}
;        {nb, 'ROT X '}
        bVertical = false
    endif
    if iProgendmode eq 1
        {nb, 'M30 '}
    endif
    if iProgendmode eq 2
        {nb, 'M2 '}
    endif

endp

;-------------------

@end_of_file
    ; Handle end of file character
    if i4xIndexMode eq 2 and !bLimit_3axis ;Trig Macro
        call @usr_trig_macro_output
    endif
    if cPe ne ''
        {nl,cPe}
    endif
    if bMultiplefixtures eq True
        bFromendoffile = True
        call @Multiple_Fixtures
    endif
endp

;-------------------

@relative_mode
    ; Handle setting of IncrementalMode Gcode
    iAbsincmode = 91
endp

@absolute_mode
    ; Handle setting of AbsoluteMode Gcode
    iAbsincmode = 90
endp

@usr_abs_inc_output
    ; Handle output of Absolute/Incremental Mode Gcode
    {['G'iAbsincmode, ' ']}
endp

;-------------------

@machine_plane
    ; Handle setting of MachinePlane Gcode
    ; We not use this procedure to output code
    ; We create our own procedure for this so that we may Sync with arc_zx_yz
    if machine_plane eq XY
        iMplane = 17
    endif
    if machine_plane eq ZX
        iMplane = 18
    endif
    if machine_plane eq YZ
        iMplane = 19
    endif
endp

@usr_mp_output
    ; Handle output of MachinePlane Gcode
    ; Use bStartFile variable to ignore this output at beginning of file
    {['G'iMplane' ']}
endp

;-------------------

@home_number
    ; Handle setting WorkOffset Gcode
    if iWorkOffset_Method eq 0
        if iWorkOffsetmode eq 1
            newshift_x = ((cos(-rotate_angle_y)*cos(rotate_angle_z)*shift_x) - (sin(rotate_angle_z)*cos(-rotate_angle_y)*shift_y) + (sin(-rotate_angle_y)*shift_z))
            newshift_y = ((-sin(rotate_angle_x)*sin(-rotate_angle_y)*cos(rotate_angle_z) + cos(rotate_angle_x)*sin(rotate_angle_z))*shift_x) + ((sin(rotate_angle_x)*sin(-rotate_angle_y)*sin(rotate_angle_z) + cos(rotate_angle_x)*cos(rotate_angle_z))*shift_y) - (sin(rotate_angle_x)*cos(-rotate_angle_y)*shift_z)
            newshift_z = -(((cos(rotate_angle_x)*cos(rotate_angle_z)*sin(-rotate_angle_y) + sin(rotate_angle_x)*sin(rotate_angle_z))*shift_x) + ((-sin(rotate_angle_z)*cos(rotate_angle_x)*sin(-rotate_angle_y) + sin(rotate_angle_x)*cos(rotate_angle_z))*shift_y)  - (cos(rotate_angle_x)*cos(-rotate_angle_y)*shift_z))
            iWorkoffset = 54
            ORGXYZ = position
        endif
        if iWorkOffsetmode eq 2 or iWorkOffsetmode eq 3
            iWorkoffset = tonum(substr(home_user_name,(instr(home_user_name,'P') + 1),2))
            if iWorkoffset eq 0
                iWorkoffset = tonum(substr(home_user_name,(instr(home_user_name,'p') + 1),2))
                if iWorkoffset eq 0
                    iWorkoffset = position
                endif
            endif
        endif
    else
        iWorkoffset = tonum(home_user_name)
    endif
endp

@usr_homenumber_output
    ; Handle output WorkOffset Gcode
    {[cWo,iWorkoffset' ']}
    change(cWo) = false
    change(iWorkoffset) = false
endp

;-------------------

@change_tool
    ; Delayed Tool Change handling to @start_of_job to have access to Operation(Job) data
    nTcXnext = xnext
    nTcYnext = ynext
    nTcZnext = tool_start_plane

    nTcCnext = cnext
    bTlchg = true
endp

@usr_ct
    ; Handle all aspects of Tool Change
    if bMultiplefixtures eq True
        bFrombeginchangetool = True
        call @Multiple_Fixtures
    endif
    if !first_tool
        iTcnumber = iTcnumber + 1
    endif
    bStartFile = false
    call @usr_tc_init_gmstates
    if !bsubs
        if !first_tool
            call @usr_ct_before_notfirsttool
        endif
        if first_tool
            iFirst_tool = tool_number
            call @usr_ct_before_firsttool
        endif
    endif
    call @usr_ct_toolchange
    if !bsubs
        call @usr_ct_after
    endif
    if !bMultiplefixtures
;		bSkipxyrapid = true
    endif
    if bMultiplefixtures eq True
        bFromendchangetool = True
        call @Multiple_Fixtures
    endif
endp

@usr_ct_before_notfirsttool
    ; Handle output before the next tool change
    ; This is not called before the first tool change
    if !bStopM00difftool
        if bCooloffend and bCoolExist
            iCoolantM1 = iCoolantM1OFF
            iCoolantM2 = iCoolantM2OFF
            iCoolantM3 = iCoolantM3OFF
            iCoolantM4 = iCoolantM4OFF
            iCoolantM5 = iCoolantM5OFF
            iCoolantM6 = iCoolantM6OFF
            iCoolantM7 = iCoolantM7OFF
            iCoolantM8 = iCoolantM8OFF
            change(iCoolantM1) = true
            change(iCoolantM2) = false
            change(iCoolantM3) = false
            change(iCoolantM4) = false
            change(iCoolantM5) = false
            change(iCoolantM6) = false
            change(iCoolantM7) = false
            change(iCoolantM8) = false
            bskipline = true
            call @usr_coolant_output
        endif
        if bSpinoffend
            iSpindleDir = 5
            {nb}
            call @usr_spindle_mcode_output
        endif
        if bVertical or bFirstVert
            sHomestrrot = sHomestrrotv
            if sHomestrrot ne ''
                sHomestr = sHomestrrot
                call @usr_prep_home_axis
            endif
            ; {nb, 'HVH'}
            zpos_f = '5.4'
;                {nb, 'ROT X '}
            bVertical = false
            bFirstVert = false
        else
            if sHomestrtc ne ''
                sHomestr = sHomestrtc
                call @usr_prep_home_axis
            endif
        endif
        if bOptstptc
            call @usr_optionalstop
        endif
    endif
    if bTcseperation
        {nl}
    endif
    bSafetyprep = true
    call @usr_tc_init_gmstates
    if bNnumtc
        {nl,'N'iTcnumber' '}
        skipline = false
    else
        {nb,cCb}
    endif
    {nb, 'G17 G64 G90'}
endp

@usr_ct_before_firsttool
    ; Handle output before the first tool change
    bSafetyprep = true
    call @usr_tc_init_gmstates
    if bNnumtc
        {nl,'N'iTcnumber' '}
        skipline = false
    else
        {nb,cCb}
    endif
    {nb, 'G17 G64 G90'}
endp

@usr_ct_toolchange
    ; Handle G/M code output to make tool change
    {nb, 'T',tool_number,cTCcodes}
    {nb, cTCcodep}
;    if tool_message == '' then
;        {' ' cCb'TOOL 'tool_number, ' - DIA '(tool_offset*2),cCe }
;    else
;        {' ' cCb'T'tool_number,'-' tool_message,cCe}
;    endif

    if bToolPreselect
        if !last_tool
            {nb, 'T'next_tool_number' '}
;        else
;            if !bToolChangeAtEnd
;                {nb, 'T'iFirst_tool}
;            endif
        endif
    endif
    if !bsubs
        {nb, cOMb,job_name,cOMe}
    endif
endp

@usr_ct_after
    ; Handle output after tool change
    ; *Note: Coolant & job Options need handling
    local integer i poz1 l1b pr1
    local string msg1 msg1a msg1b
    if msg ne ''
        i = 1
        while i < 50
            i = i + 1
            poz1=instr(msg,'\n')
            if poz1 eq 0
                poz1=strlen(msg)
                msg1=msg
            else
                poz1 = poz1-2
                msg1=left(msg,poz1)
            endif
            {nb, cCb,msg1,cCe}
            poz1=instr(msg,'\n')
            if poz1 eq 0
                i = 51
            else
                l1b=strlen(msg)-strlen(msg1)
                pr1=poz1+1
                msg1b=substr(msg,pr1,l1b)
                msg=msg1b
            endif
        endw
    endif
    ; ---- 4x
    if i4xIndexMode eq 2 and !bLimit_3axis ;Trig Macro
        call @usr_r1pos_calc
        call @usr_trig_macro_call
        iWorkoffset = 112
        nR1pos = 9999
    endif
    ; ---- 4x
    if bCoolspinaftertc
        skipline = true
        call @start_tool
        if bCoolExist and !bsubs
            skipline = true
            call @usr_coolant
        endif
        if !bsubs
            xpos = nTcXnext
            ypos = nTcYnext
            cpos = nTcCnext
            change(zpos) = false
            call @usr_rapid
;	    call @usr_heightcomp_on
        endif
    else
        if !bsubs
            xpos = nTcXnext
            ypos = nTcYnext
            cpos = nTcCnext
            change(zpos) = false
            skipline = true
            call @usr_rapid
            if bCoolExist
                skipline = false
                call @usr_coolant
            endif
            skipline = false
            call @start_tool
        endif
    endif
;    bSkipxyrapid = true
endp

@usr_tc_init_gmstates
    ; Handle initializing G/M codes for correct modality after tool change
    if first_tool
        iMotionmode = 9999
        iDiametercomp = 40
        change(iAbsincmode) = false
        call @machine_plane
        change(iMplane) = true
        change(iWorkoffset) = true
        change(iDiameteroffset) = false
        change(iDiametercomp) = false
;		iHeightcomp = 9999
        iDrillmode = 9999
;		iCoolantM1 = iCoolantM1OFF
;		iCoolantM2 = iCoolantM2OFF
;		iCoolantM3 = iCoolantM3OFF
;		iCoolantM4 = iCoolantM4OFF
;		iCoolantM5 = iCoolantM5OFF
;		iCoolantM6 = iCoolantM6OFF
;		iCoolantM7 = iCoolantM7OFF
;		iCoolantM8 = iCoolantM8OFF
    else
        if bSafetyprep
            call @machine_plane
            change(iMplane) = true
            change(iAbsincmode) = false
            change(iDiametercomp) = false
            iDrillmode = 9999
            bSafetyprep = false
        else
            iMotionmode = 9999
            if bWorkoffsettc
                change(iWorkoffset) = true
            endif
            change(iAbsincmode) = false
            iDiametercomp = 40
            change(iDiameteroffset) = false
            iHeightcomp = 9999
            iDrillmode = 9999
;			iCoolantM1 = iCoolantM1OFF
;			iCoolantM2 = iCoolantM2OFF
;			iCoolantM3 = iCoolantM3OFF
;			iCoolantM4 = iCoolantM4OFF
;			iCoolantM5 = iCoolantM5OFF
;			iCoolantM6 = iCoolantM6OFF
;			iCoolantM7 = iCoolantM7OFF
;			iCoolantM8 = iCoolantM8OFF
            change(nRapidfeed) = true
            ; ---- 4x
            nR1pos = 9999
            apos = 0
            bpos = 0
            cpos = 0
            ; ---- 4x
        endif
    endif
endp

@usr_heightcomp_on
    ; Handle line to turn on Height Compensation (Typically after tool change)
    iHeightcomp = 43
    {nb, 'G'iHeightcomp, ' H'tool_number' '}
    if !bsubs
        skipline = false
        zpos = nTcZnext
        change(xpos) = false
        change(ypos) = false
        call @rapid_move
    endif
endp

@usr_heightcomp_off
    ; Handle line to turn off Height Compensation (Typically don't use)
    iHeightcomp = 49
    if change(iHeightcomp)
        {nb, 'G'iHeightcomp' '}
    endif
endp

@usr_coolant
    ; Handle setting of coolant variable
    ; When GlobalCode = 0, we use UserOption for thier default CoolantCode
    ;  *Note: PartOptions default to 0 in SolidCAM
    ;  *Note: Some customers default with M8(coolant), but some use M7(air) or M9(nothing)
    ; We use GlobalCode for coolant unless
    ;  the user inputs a number for LocalCode (Misc Params--Operation)
    if flood_coolant eq 1
        iCoolantM1 = iCoolantM1ON
        bskipline = false
    endif
    if flood_coolant eq 0 or flood_coolant eq 2
        iCoolantM1 = iCoolantM1OFF
        bskipline = true
    endif
    if Mist_coolant eq 1
        iCoolantM2 = iCoolantM2ON
        bskipline = false
    endif
    if Mist_coolant eq 0 or Mist_coolant eq 2
        iCoolantM2 = iCoolantM2OFF
        bskipline = true
    endif
    if HP_Flood_coolant eq 1
        iCoolantM3 = iCoolantM3ON
        bskipline = false
    endif
    if HP_Flood_coolant eq 0 or HP_Flood_coolant eq 2
        iCoolantM3 = iCoolantM3OFF
        bskipline = true
    endif
    if LP_Flood_coolant eq 1
        iCoolantM4 = iCoolantM4ON
        bskipline = false
    endif
    if LP_Flood_coolant eq 0 or LP_Flood_coolant eq 2
        iCoolantM4 = iCoolantM4OFF
        bskipline = true
    endif
    if through_ival_coolant eq 1
        if through_coolant_val eq 5
            iCoolantM5ON = 77
        endif
        if through_coolant_val eq 10
            iCoolantM5ON = 76
        endif
        if through_coolant_val eq 15
            iCoolantM5ON = 75
        endif
        if through_coolant_val eq 30
            iCoolantM5ON = 07
        endif
        if through_coolant_val eq 40
            iCoolantM5ON = 71
        endif
        if through_coolant_val eq 50
            iCoolantM5ON = 72
        endif
        if through_coolant_val eq 60
            iCoolantM5ON = 73
        endif
        if through_coolant_val eq 70
            iCoolantM5ON = 74
        endif
        iCoolantM5 = iCoolantM5ON
        bskipline = false
    endif
    if through_ival_coolant eq 0 or through_ival_coolant eq 2
        iCoolantM5 = iCoolantM5OFF
        bskipline = true
    endif
    if LP_Through_coolant eq 1
        iCoolantM6 = iCoolantM6ON
        bskipline = false
    endif
    if LP_Through_coolant eq 0 or LP_Through_coolant eq 2
        iCoolantM6 = iCoolantM6OFF
        bskipline = true
    endif
    if Air_Blast_coolant eq 1
        iCoolantM7 = iCoolantM7ON
        bskipline = false
    endif
    if Air_Blast_coolant eq 0 or Air_Blast_coolant eq 2
        iCoolantM7 = iCoolantM7OFF
        bskipline = true
    endif
    if air_through_coolant eq 1
        iCoolantM8 = iCoolantM8ON
        bskipline = false
    endif
    if air_through_coolant eq 0 or air_through_coolant eq 2
        iCoolantM8 = iCoolantM8OFF
        bskipline = true
    endif
    call @usr_coolant_output
endp

@usr_coolant_output
    ; Handle output of coolant variable
    if change(iCoolantM1)
        {nb,['M'iCoolantM1:mcode_f' ']}
        skipline = bskipline
    endif
    if change(iCoolantM2)
        {nb,['M'iCoolantM2:mcode_f' ']}
        skipline = bskipline
    endif
    if change(iCoolantM3)
        {nb,['M'iCoolantM3:mcode_f' ']}
        skipline = bskipline
    endif
    if change(iCoolantM4)
        {nb,['M'iCoolantM4:mcode_f' ']}
        skipline = bskipline
    endif
    if change(iCoolantM5)
        {nb,['M'iCoolantM5:mcode_f' ']}
        skipline = bskipline
    endif
    if change(iCoolantM6)
        {nb,['M'iCoolantM6:mcode_f' ']}
        skipline = bskipline
    endif
    if change(iCoolantM7)
        {nb,['M'iCoolantM7:mcode_f' ']}
        skipline = bskipline
    endif
    if change(iCoolantM8)
        {nb,['M'iCoolantM8:mcode_f' ']}
        skipline = bskipline
    endif
    if  !change(iCoolantM1) or  !change(iCoolantM2) or !change(iCoolantM3) or  !change(iCoolantM4) or !change(iCoolantM5) or  !change(iCoolantM6) or !change(iCoolantM7) or !change(iCoolantM8)
        skipline = TRUE
    endif
endp

@usr_HSM_mode
    ; Handle output of HSM code
    if iG187_P eq 0
        iG187_P = 2 ;Default = 2
    endif
    iG187_P_gpp = iG187_P
    nG187_E_gpp = nG187_E
    if change(iG187_P_gpp) or change (nG187_E_gpp)
        if change(nG187_E_gpp) and nG187_E_gpp eq 0
            {nb,'G187 '}
            change(nG187_E_gpp) = false
            change(iG187_P_gpp) = false
            if (iG187_P_gpp) ne 2
                change(iG187_P_gpp) = true
            endif
        endif
        if change(iG187_P_gpp) or change (nG187_E_gpp)
            {nb,'G187 '['P'iG187_P_gpp' ']['E'nG187_E_gpp' ']}
        endif
        change(iG187_P_gpp) = false
        change(nG187_E_gpp) = false
    endif
endp

;--------------------

@start_of_job
    ; Handle what happens at start of operation(job)
    ; If using Subs we do not make tool change in @start_of_job
    call @home_number
    if rot_axis_coord eq 2
        Xpos = 0
        Xnext = 0
        nTcXnext = 0
    endif
    if bSubs
        {nb, cOMb,job_name,cOMe}
        xpos = xnext
        ypos = ynext
        change(xpos) = true
        change(ypos) = true
        change(zpos) = false
        change(iAbsincmode) = true
        change(iWorkoffset) = false
        iMotionmode = 1
        change(iDiameteroffset) = false
        bSkipxyrapid = false
        spin = spin_rate
        change(spin) = false
        call @rapid_move
        call @start_tool
        if bCoolExist
            call @usr_coolant
        endif
        change(xpos) = false
        change(ypos) = false
        change(zpos) = true
        call @rapid_move
    else
        if bTlchg
            call @usr_ct
            bTlchg = false
            bFirstMovetlch = true
        else
            bFirstRapid = true
            {nb, cOMb,job_name,cOMe}
            ; ---- 4x
            ; ---- 4x
            if iPworkoffset ne iWorkoffset and !bLimit_3axis   ; Cannot use multiple MAC offsets with 4x
                call @usr_tc_init_gmstates
                bTlchg = true
                call @rapid_move
            endif
        endif
    endif
    ;Special
    local integer var_num
    if bPrintloop
        var_num = loop_level + 20
        {nb, '#', var_num, ' = 0'}
        {nb, 'WHILE [#', var_num, ' LT ', loop_count, '] DO ', loop_level}
        bPrintloop = false
    endif
    ;Special
    if job_type eq 'drill_hr' or X5_job or transform_type eq 3
        bSkipxyrapid = false
    endif
    call @usr_HSM_mode
    bFirstMove = true
endp

;--------------------

@end_of_job
    ; Handle what happens at end of operation(job)
    ; If using Subs we do not make tool change in @start_of_job
    if bStopM00
        if tool_number eq next_job_tool_number
            call @usr_StopM00_sametool
        else
            call @usr_StopM00_difftool
        endif
    endif
    bSkipxyrapid = false
    bStopM00difftool = false
    iPworkoffset = iWorkoffset
    ; ---- 4x
    ;if tool_z_level < tool_start_plane
    ;    Print 'WARNING!! Tool Z Level is below Tool Start Plane in CoordSys'
    ;    {nl,'WARNING!! Tool Z Level is below Tool Start Plane in CoordSys'}
    ;endif
    nPtool_z_level = tool_z_level
    nPtool_start_plane = tool_start_plane
    ; ---- 4x
;    if bCoolExist and !bsubs
;	    call @usr_coolant
;    endif
endp

;-------------------

@rapid_move
    ; Handle GPP direct call to Rapid Move (G00)
    ; We not use this procedure to output code
    ; We create our own procedure for this so that we may...
    ;   Sync with @rapid_move, @move_5x, @move_4x, @move4x_polar, @move4x_cartesian
    call @usr_rapid
endp

@usr_rapid
    ; Handle output for Rapid Move (G00)
    ; Note: XYZ not allowed together on a single line
    ; ---- 4x
    ;   - Set Rotary Position
    if !bSyncdrapid
        if job_type eq '3-d model'
            iMotionmode = 1
        else
            iMotionmode = 0
        endif
    else
        iMotionmode = 0
    endif

    call @usr_r1pos_calc
    if bFirstRapid or bTlchg
        if abs(nR2pos) gt 0
            if !bVertical or bFirstVert
                sHomestrrot = sHomestrrotv
                if sHomestrrot ne ''
                    sHomestr = sHomestrrot
                    call @usr_prep_home_axis
                endif
                {nb, 'HVV'}
                zpos_f = '5.4(*-1)'
;                {nb, 'ROT X90. '}
                bVertical = true
                bFirstVert = false
            endif
        else
            if bVertical or bFirstVert
                sHomestrrot = sHomestrrotv
                if sHomestrrot ne ''
                    sHomestr = sHomestrrot
                    call @usr_prep_home_axis
                endif
;               {nb, 'HVH'}
                zpos_f = '5.4'
;                {nb, 'ROT X '}
                bVertical = false
                bFirstVert = false
            endif
        endif
        bFirstRapid = false
    endif
    if change(nr1pos)
        sHomestrrot = sHomestrroth
        if sHomestrrot ne ''
            sHomestr = sHomestrrot
            call @usr_prep_home_axis
        endif
    endif
    if bTlchg or bFirstRapid
        zpos = tool_start_plane
;		{nb, 'M11'}
;		{nb, 'G04 K200'}
        if bVertical
            {nb,'G'iMotionmode:mcode_f ' ',['G'iMplane' '],'G'iAbsincmode ' ',cWo,iWorkoffset' ','Y'ypos ' ',cR1,nR1pos ' '}
        else
            {nb,'G'iMotionmode:mcode_f ' ',['G'iMplane' '],'G'iAbsincmode ' ',cWo,iWorkoffset' ',cR1,nR1pos ' '}
        endif
;		{nb, 'G04 K800'}
;		{nb, 'M10'}
        bTlchg = false
        bFirstRapid = false
;        bSkipxyrapid = true
    else
        if !change(nR1pos) and !change(xpos) and !change(ypos) and !change(zpos)  ;Ignore apos prepositioning, handled at toolchange
            skipline = false
        endif
        ; ---- 4x
        if !bSkipxyrapid
            {nb,['G'iMotionmode:mcode_f ' '],['G'iMplane' '],['G'iAbsincmode ' '],[cWo,iWorkoffset' '],['X'xpos ' '],['Y'ypos ' ']}
            if change(zpos)
                if bFirstMove  ;!@#$% clear change
                    bFirstMovetlch = false
                    skipline = true
                    {nb,'Z'zpos ' ' }
                    bFirstMove = false
                    skipline = true
                else
                    {'Z'zpos ' ' }
                endif
            endif
            if !bSyncdrapid
                if job_type eq '3-d model'
                    {['F'nRapidfeed' ']}
                endif
            endif
            bSkipxyrapid = false
        else
            if bVertical
                {nb,'X'xpos ' ','Z'zpos ' ' }
            else
                {nb,'X'xpos ' ','Y'ypos ' '}
                {nb,'Z'zpos ' ' }
            endif
            if !bSyncdrapid
                if job_type eq '3-d model'
                    {['F'nRapidfeed' ']}
                endif
            endif
            bSkipxyrapid = false
        endif
    endif
    if !bSyncdrapid
        bFeedoutput        = true
    endif
    change(cWo) = false
    change(iWorkoffset) = false
endp

;-------------------

@line
    ; Handle GPP direct call to Line Movement (G01)
    ; We not use this procedure to output code
    ; We create our own procedure for this so that we may...
    ;   Sync with @line, @line_5x, @line_4x, @line4x_polar, @line4x_cartesian
    call @usr_line
endp

@usr_line
    ; Handle output for line movement (G01)
    ; ---- 4x
    ;   - Set Rotary Position
    call @usr_r1pos_calc
    if next_command eq '@compensation' and iMotionmode ne 0
        side = tool_side
        call @compensation
    endif
    iMotionmode = 1
    ; ---- 4x
    if bFeedoutput
        change(feed) = true
        bFeedoutput  = false
    endif
;    if change(iFeedType)
;        change(iMotionmode) = true
;        {nb,['G'iFeedType' ']}
;    endif
    {nb,['G'iMotionmode:mcode_f ' '],['G'iMplane' '],['G'iDiametercomp' '],[cWo,iWorkoffset' '],['G'iAbsincmode ' ']}
    {['X'xpos ' '],['Y'ypos ' '],['Z'zpos ' '],[cR1,nR1pos ' '],['F'feed ' ']}
    prevFeed = feed
    change(nRapidfeed) = true
endp

; -----------
@arc
    ; SolidCAM call to normal arc movement
    ; We do not use this procedure to output code
    ; We create our own procedure for this so that we have one arc formatting section
    call @usr_arc
endp

@arc_yz
    ; SolidCAM call to YZ arc movement
    ; We not use this procedure to output code
    ; We create our own procedure for this so that we have one arc formatting section
    if bFeedoutput
        change(feed) = true
        bFeedoutput  = false
    endif
    if arc_direction eq CCW then
        iMotionmode = 3
    else
        iMotionmode = 2
    endif
    if arc_plane eq XY
        iMplane = 17
    endif
    if arc_plane eq ZX
        iMplane = 18
    endif
    if arc_plane eq YZ
        iMplane = 19
    endif
    {nb,['G'iMotionmode:mcode_f ' '],['G'iMplane' '],['G'iDiametercomp' '],[cWo,iWorkoffset' '],['G'iAbsincmode ' ']}
    {['X'xpos ' '],['Y'ypos ' '],['Z'zpos ' ']}
    if arc_plane eq YZ then
        if iArcmode eq 1 or (arc_size eq 360 and iArcmode eq 3)
            {'J'ycenter ' ', 'K'zcenter ' '}
        endif
        if iArcmode eq 2 or (arc_size eq 360 and iArcmode eq 4)
            {'J'ycenter_rel ' ', 'K'zcenter_rel ' '}
        endif
        if (iArcmode eq 3 or iArcmode eq 4) and arc_size ne 360
            if arc_size >= 180 then
                radius = -radius
            endif
            {'R'radius' '}
        endif
    endif
    {['F'feed ' ']}
    change(nRapidfeed) = true
endp

@arc_zx
    ; SolidCAM call to ZX arc movement
    ; We not use this procedure to output code
    ; We create our own procedure for this so that we have one arc formatting section
    if bFeedoutput
        change(feed) = true
        bFeedoutput  = false
    endif
    if arc_direction eq CCW then
        iMotionmode = 3
    else
        iMotionmode = 2
    endif
    if arc_plane eq XY
        iMplane = 17
    endif
    if arc_plane eq ZX
        iMplane = 18
    endif
    if arc_plane eq YZ
        iMplane = 19
    endif
    {nb,['G'iMotionmode:mcode_f ' '],['G'iMplane' '],['G'iDiametercomp' '],[cWo,iWorkoffset' '],['G'iAbsincmode ' ']}
    {['X'xpos ' '],['Y'ypos ' '],['Z'zpos ' ']}
    if arc_plane eq ZX then
        if iArcmode eq 1 or (arc_size eq 360 and iArcmode eq 3)
            {'I'xcenter ' ', 'K'zcenter ' '}
        endif
        if iArcmode eq 2 or (arc_size eq 360 and iArcmode eq 4)
            {'I'xcenter_rel ' ', 'K'zcenter_rel ' '}
        endif
        if (iArcmode eq 3 or iArcmode eq 4) and arc_size ne 360
            if arc_size >= 180 then
                radius = -radius
            endif
            {'R'radius' '}
        endif
    endif
    {['F'feed ' ']}
    change(nRapidfeed) = true
endp

@usr_arc
    ; Handle output for arc movement (G02/G03)
    if bFeedoutput
        change(feed) = true
        bFeedoutput  = false
    endif
    if arc_direction eq CCW then
        iMotionmode = 3
    else
        iMotionmode = 2
    endif
    if arc_plane eq XY
        iMplane = 17
    endif
    if arc_plane eq ZX
        iMplane = 18
    endif
    if arc_plane eq YZ
        iMplane = 19
    endif
    {nb,['G'iMotionmode:mcode_f ' '],['G'iMplane' '],['G'iDiametercomp' '],[cWo,iWorkoffset' '],['G'iAbsincmode ' ']}
    {['X'xpos ' '],['Y'ypos ' '],['Z'zpos ' ']}
    if arc_plane eq XY then
        if iArcmode eq 1 or (arc_size eq 360 and iArcmode eq 3)
            {'I'xcenter ' ', 'J'ycenter ' '}
        endif
        if iArcmode eq 2 or (arc_size eq 360 and iArcmode eq 4)
            {'I'xcenter_rel ' ', 'J'ycenter_rel ' '}
        endif
        if (iArcmode eq 3 or iArcmode eq 4) and arc_size ne 360
            if arc_size >= 180 then
                radius = -radius
            endif
            {'R'radius' '}
        endif
    endif
    if arc_plane eq ZX then
        if iArcmode eq 1 or (arc_size eq 360 and iArcmode eq 3)
            {'I'xcenter ' ', 'K'ycenter ' '}
        endif
        if iArcmode eq 2 or (arc_size eq 360 and iArcmode eq 4)
            {'I'xcenter_rel ' ', 'K'(-ycenter_rel) ' '}
        endif
        if (iArcmode eq 3 or iArcmode eq 4) and arc_size ne 360
            if arc_size >= 180 then
                radius = -radius
            endif
            {'R'radius' '}
        endif
    endif
    if arc_plane eq YZ then
        if iArcmode eq 1 or (arc_size eq 360 and iArcmode eq 3)
            {'J'ycenter ' ', 'K'zcenter ' '}
        endif
        if iArcmode eq 2 or (arc_size eq 360 and iArcmode eq 4)
            {'J'ycenter_rel ' ', 'K'zcenter_rel ' '}
        endif
        if (iArcmode eq 3 or iArcmode eq 4) and arc_size ne 360
            if arc_size >= 180 then
                radius = -radius
            endif
            {'R'radius' '}
        endif
    endif
    {['F'feed ' ']}
    change(nRapidfeed) = true
endp

;-------------------

@compensation
    ; Handle setting of Diameter Compensation Gcode
    ; We not use this procedure to output code
    ; We create our own procedure for this so that we..
    ;   have can control placement during @line,@arc
    if side eq COMP_LEFT then
        iDiametercomp = 41
        change(iDiameteroffset) = true
    endif
    if side eq COMP_RIGHT then
        iDiametercomp = 42
        change(iDiameteroffset) = true
    endif
    if side eq COMP_OFF then
        iDiametercomp = 40
        change(iDiameteroffset) = false
    endif
endp

@usr_compensation_output
    ; Handle output of Diameter Compensation Gcode
    if change(iDiametercomp)
        if iDiametercomp eq 40
            {'G'iDiametercomp' '}
        else
            {'G'iDiametercomp, ' D'tool_number' '}
        endif
    endif
endp

;-------------------

@usr_optionalstop
    ; Handle line for Optional Stop G/M code
    iStopmode = 1
    {nb, 'M'iStopmode:mcode_f' '}
endp

@usr_forcedstop
    ; Handle line for forced Stop gmcode
    iStopmode = 0
    {nb, 'M'iStopmode:mcode_f' '}
endp

@usr_StopM00_sametool
    ; Handle output for forced stopM00 between operations using the same tool
    if bCoolExist
        iCoolantM1 = iCoolantM1OFF
        iCoolantM2 = iCoolantM2OFF
        iCoolantM3 = iCoolantM3OFF
        iCoolantM4 = iCoolantM4OFF
        iCoolantM5 = iCoolantM5OFF
        iCoolantM6 = iCoolantM6OFF
        iCoolantM7 = iCoolantM7OFF
        iCoolantM8 = iCoolantM8OFF
        change(iCoolantM1) = true
        change(iCoolantM2) = false
        change(iCoolantM3) = false
        change(iCoolantM4) = false
        change(iCoolantM5) = false
        change(iCoolantM6) = false
        change(iCoolantM7) = false
        change(iCoolantM8) = false
        bskipline = true
        call @usr_coolant_output
    endif
    iSpindleDir = 5
    {nb}
    call @usr_spindle_mcode_output
    if sHomestrstpsame ne ''
        sHomestr = sHomestrstpsame
        call @usr_prep_home_axis
    endif
    call @usr_forcedstop
    sUsrmsg = sStopMessage
    call @usr_message
    {nb}
    call @usr_abs_inc_output
    call @m_feed_spin
    call @usr_spindle_mcode_output
    change(xpos) = true
    change(ypos) = true
    change(zpos) = false
    call @rapid_move
;	call @usr_heightcomp_on
endp

@usr_StopM00_difftool
    ; Handle output for forced stopM00 between operations using different tools
    if bCoolExist
        iCoolantM1 = iCoolantM1OFF
        iCoolantM2 = iCoolantM2OFF
        iCoolantM3 = iCoolantM3OFF
        iCoolantM4 = iCoolantM4OFF
        iCoolantM5 = iCoolantM5OFF
        iCoolantM6 = iCoolantM6OFF
        iCoolantM7 = iCoolantM7OFF
        iCoolantM8 = iCoolantM8OFF
        change(iCoolantM1) = true
        change(iCoolantM2) = false
        change(iCoolantM3) = false
        change(iCoolantM4) = false
        change(iCoolantM5) = false
        change(iCoolantM6) = false
        change(iCoolantM7) = false
        change(iCoolantM8) = false
        bskipline = true
        call @usr_coolant_output
    endif
    iSpindleDir = 5
    {nb}
    call @usr_spindle_mcode_output
    if sHomestrstpdiff ne ''
        sHomestr = sHomestrstpdiff
        call @usr_prep_home_axis
    endif
    call @usr_forcedstop
    sUsrmsg = sStopMessage
    call @usr_message
    bStopM00difftool = true
endp

;-------------------

@change_ref_point
    ; @change_ref_point Not Supported in this template
    gcode = 91
    {nb, 'G'gcode}
    gcode = 10
    {' G'gcode ' L2 P'home_number ' X'xhome, ' Y'yhome, ' Z'zhome}
    {nb 'G90'}
endp

;-------------------

@rotate
    ; @rotate Not Supported in this template
endp

;-------------------

@mirror
    ; @mirror Not Supported in this template
endp

;-------------------

@fourth_axis
    if angle eq 0
        position = 1
    else
        position = position + 1
    endif
    if bsubs
;    {nb,'M11'}
;    {nb,'M13'}
;    {nb,'G54 G0 G90 A0. B0'}
;    {nb,'G10 G90 L2 P1 B',angle}
    else
        gcode = 0
        apos = angle -opposite_z_angle_const_y
    endif
endp
;-------------------

@message
    ; We don't use messages directly from SolidCAM
endp

@usr_message
    ; Handle output for messages
    ; We don't use messages directly from SolidCAM
    if sUsrmsg ne ''
        {nb, cCb,sUsrmsg,cCe}
    endif
endp

;-------------------

@drill
    local numeric rtp rfp sdis dp
    rtp = drill_clearance_z
    rfp = (drill_upper_z - safety)
    sdis = safety
    dp = drill_lower_z

;    if !first_drill
;change(zpos) = false
    call @rapid_move
;    endif
    if drill_type eq G81 then
        gcode = 81
    endif
    if drill_type eq G82 then
        gcode = 82
    endif
    if drill_type eq G83 then
        gcode = 83
    endif
    if drill_type eq G84 then
        gcode = 84
    endif
    if drill_type eq G86 then
        gcode = 86
    endif
    {nb,' F'feed }
    {nb,'MCALL CYCLE',gcode}

    if drill_type eq G81 then ;---------------------
        if drill_upper_z > 0
            {' (',rtp,',,'sdis,',',dp,',',rfp}
        else
            {' (',rtp,','drill_upper_z,',,',dp,',','0.'}
        endif
        {')'}
    endif


    if drill_type eq G82 then ;-------------------------
        if drill_upper_z > 0
            {' (',rtp,',,'sdis,',',dp,',',rfp}
        else
            {' (',rtp,','drill_upper_z,',,',dp,',','0.'}
        endif
        {','delay,')'}
    endif



    if drill_type eq G83 then ;--------------------------
        if drill_upper_z > 0
            {' (',rtp,',,'sdis,',',dp,',',rfp}
            {',,',down_step,','down_step,',,,1,1)'}
        else
            {' (',rtp,',',drill_upper_z',,',dp}
            {',0.,,',down_step,','down_step,',,,1,1)'}
        endif
    endif


    if drill_type eq G84 then ;---------------------------
        if drill_upper_z > 0
            {' (',rtp,',,'sdis,',',dp,',',rfp,',0.,3,,',''(FEED/SPIN),',0,''',SPIN:INTEGER_DEF_F,','(SPIN*2):INTEGER_DEF_F}
        else
            {' (',rtp,','drill_upper_z,',,',dp,',','0.'}
            {',0.,3,,',''(FEED/SPIN),',0,''',SPIN:INTEGER_DEF_F,','(SPIN*2):INTEGER_DEF_F}
        endif
        {',,,1221'}
        if Step_Down ne 0
            if VarRetract ne 0
                {',1,'Step_Down:feed_f ',' VarRetract:feed_f}
            else
                {',1,'Step_Down:feed_f ',' Step_Down:feed_f}
            endif
        endif

        {')'}
    endif

    if drill_type eq G86 then ;--------------------------
        if drill_upper_z > 0
            {' (',rtp,',,'sdis,',',dp,',',rfp,',,3'}
        else
            {' (',rtp,','drill_upper_z,',,',dp,',','0.,,3'}
        endif
        {')'}
    endif

endp

;-------------------

@drill_point
    ; Handle output for drill positions
;    if !first_drill then
    {nb,['X'xpos ' '], ['Y'ypos ' '], ['Z'zpos ' ']}
;    endif
endp


;-------------------

@end_drill
    ; Handle output to cancel drill cycles
    iDrillmode = 80
    if change(iDrillmode)
        {nb, 'MCALL '}
        iDrillmode = 9999
    endif
    if drill_type eq G84
        {nb, 'G94'}
    endif
endp

;-------------------

@m_feed_spin
    ; Handle output for spindle change
    if tool_direction eq CW then
        iSpindleDir = 3
    else
        iSpindleDir = 4
    endif
    if change(spin)
        ; call @usr_spindle_mcode_output
        call @usr_spindle_output
    endif
endp

@start_tool
    ; Handle setting and output for spindle start
    if tool_direction eq CW then
        iSpindleDir = 3
    else
        iSpindleDir = 4
    endif
    if d_drill_type ne D_Tapping
        call @usr_spindle_mcode_output
        call @usr_spindle_output
    else
        {nb ' '}
    endif
endp

@usr_spindle_output
    ; Handle output for spindle
    {nb,'S'spin:integer_def_f ' '}
	local integer sdiff
	sdiff = abs(last_spin-spin)
	if sdiff > spindle_accel
	    {nb, 'G04 F', (0.3+(sdiff/500))}
		{nb}
	endif
	last_spin = spin
endp

@usr_spindle_mcode_output
    ; Handle output for spindle
	if iSpindleDir ne 3 and iSpindleDir ne 4
	    last_spin = 0
	endif
    {'M'iSpindleDir:mcode_f ' '}
endp

;-------------------

@offset_change
    ; Handle setting of Diameter offset
    iDiameteroffset = tool_number
endp

;-------------------

@job_plane
    ; @job_plane Not Supported in this template
endp

;-------------------

@call_proc
    ; Handle call to subroutine

    if btlchg
        if !first_tool
            {nb}
            change(iMplane) = true
            call @usr_abs_inc_output
            call @usr_mp_output
            side = COMP_OFF
            call @compensation
            change(iDiametercomp) = true
            call @usr_compensation_output
            skipline = false
            call @end_drill
            {'G20 '}
            if sHomestrbegin ne ''
                sHomestr = sHomestrbegin
                call @usr_prep_home_axis
            endif
        endif
        call @usr_ct
        bTlchg = false
        {nl,['('message, ')']}
        if tool_message == '' then
            {nl, cCb'TOOL 'tool_number, ' - DIA '(tool_offset*2),cCe }
        else
            {nl,cCb'T'tool_number,'-' tool_message,cCe}
        endif
    else
    endif
    call @usr_4x_index
    call @home_number
    xpos = xnext
    ypos = ynext
    zpos = tool_start_plane
    {nb,cWo,iWorkoffset' ','cR1',nR1pos} ;,'X'xpos ' ','Y'ypos ' '}
    {nb, 'M98 H'label}
    nLlabel = label
endp

;-------------------

@proc
    ; Handle beggining of subroutine
    blknum_delta = 1
    blknum = 1
    {nl, 'N'label}
    {nl,cCb,'SUB NUMBER: 'label,cCe}
endp

;-------------------

@end_proc
    ; Handle end of subroutine
    call @usr_coolant
    if sHomestrendsub ne ''
        sHomestr = sHomestrendsub
        call @usr_prep_home_axis
    endif
    {nb, 'M99'}
endp

;----------------

@loop_matrix_info
    bSkipxyrapid = false
endp

@loop
    ; Loops Not Supported in this template
    bPrintloop = true
    ;local integer var_num

    ;var_num = loop_level + 20
    ;{nb, '#', var_num, ' = 0'}
    ;{nb, 'WHILE [#', var_num, ' LT ', loop_count, '] DO ', loop_level}
    ;call @home_number
endp

@end_loop
    ; Loops Not Supported in this template
    local integer var_num

    var_num = loop_level + 20
    {nb '#', var_num, ' = #', var_num, ' + 1'}
    {nb 'END ', loop_level}
endp

;-------------------

@usr_prep_home_axis
    ; Handle parsing of homing string and preping of output for homing
    local integer i line l mode p1
    local string s s1 l1 pstr
    s = sHomestr                               ;Original String
    s1 = s                                     ;Temp String
    l = strlen(s1)                             ;Get string length of Temp String
    ;*Pull out Homing mode
    i = 1
    while i < 50
        i = i + 1
        p1 = instr(s1,':')                         ;Find the position of first ":"
        l1 = left(s1,p1-1)                         ;Pull out the left of first ":"
        mode = tonum(l1)                           ;Convert string into Integer for "Mode" variable
        s1 = substr(s1,p1+1,l)                     ;Remove Homing mode from Temp String
        l = strlen(s1)                             ;Get string length of Temp String
        ;*Pull out Preperation String
        p1 = instr(s1,':')                         ;Find the position of second ":"
        if p1 ne 0                                 ;Check if PrepStr is defined
            pstr = left(s1,p1-1)                   ;Pull out the left of second ":"
            s1 = substr(s1,p1+1,l)                 ;Remove PrepString from Temp String
            l = strlen(s1)                         ;Get string length of Temp String
        endif
        ;*Pull out homing lines and send to output procedure
        p1 = instr(s1,';')                      ;Find the position of ";"
        if p1 ne 0
            line = line + 1                     ;Keep track of lines. Not Used!!
            l1 = left(s1,p1-1)                  ;Pull out the left of ";"
            iHomingmode = mode                  ;Send Homing Mode
            cHomep = pstr                       ;Send Preperation String
            sHomeline = l1                      ;Send Homing Line
            call @usr_home_axis
        else
            line = line + 1                     ;Keep track of lines. Not Used!!
            iHomingmode = mode                  ;Send Homing Mode
            cHomep = pstr                       ;Send Preperation String
            sHomeline = s1                      ;Send Homing Line
            call @usr_home_axis
            i = 50                              ;Force end of While-Loop
        endif
        if i ne 50
            s1 = substr(s1,p1+1,l)              ;Remove Homing mode from Temp String
            l = strlen(s1)                      ;Get string length of Temp String
        endif
    endw
endp

@usr_home_axis
    ; Handle output for homing the X-axis
    local integer sav_iWorkOffset
    sav_iWorkOffset = iWorkOffset
    if iHomingmode eq 1
        {nb,cHomep'G28 'sHomeline}
    endif
    if iHomingmode eq 2
        {nb,cHomep'G28 '}
        iAbsincmode = 91
        change(iAbsincmode) = true
        call @usr_abs_inc_output
        { sHomeline}
        iAbsincmode = 90
        change(iAbsincmode) = true
    endif
    if iHomingmode eq 3 or iHomingmode eq 4
        if iWorkOffsetmode eq 1 or iWorkOffsetmode eq 3
            iWorkOffset = 53
            {nb,cHomep,['G'iWorkoffset' ']}
        endif
        if iWorkOffsetmode eq 2
            iWorkOffset = 0
            {nb,cHomep,[cWo,iWorkoffset' ']}
        endif
        call @usr_abs_inc_output
        { sHomeline}
        iWorkOffset = sav_iWorkOffset
        if iHomingmode eq 3
            change(iWorkOffset) = false
        endif
    endif
    if iHomingmode eq 5
        {nb,cHomep'G30 'sHomeline}
    endif
    if iHomingmode eq 6
        {nb,cHomep'G30 '}
        iAbsincmode = 91
        change(iAbsincmode) = true
        call @usr_abs_inc_output
        { sHomeline}
        iAbsincmode = 90
        change(iAbsincmode) = true
    endif
    if iHomingmode eq 7
        {nb,cHomep'G90 G54 'sHomeline}
    endif
    if iHomingmode eq 8
        {nb,cHomep,sHomeline}
    endif
endp

;-------------------

@usr_campart_path
    ; Uses String Functions to get the Windows Folder Path to the CAM-Part
    iSlength_g_file_name = strlen( g_file_name)
    iSlength_full_g_file_name = strlen(full_g_file_name)
    iSlengthcampartpath = iSlength_full_g_file_name - iSlength_g_file_name
    sCamfilepath = left(full_g_file_name,iSlengthcampartpath)
endp

;-------------------

@Multiple_Fixtures
    ; Handle multiple fixture support
    local integer i
;----From tools 2 and up
;----Closes the sSubspath(tempfile) for the previous tool change
;----Runs loop to print G5x and copy in the tempfile
;----Sets the tempfile to new name for next tool
    if bFrombeginchangetool eq True
        if !first_tool
            {nl,'!!close file=' sSubspath '!!'}
            i = 1
            while i <= iNumber_of_Fixtures
                {nl,cCb'-----LOOPING CODE-----'cCe}
                if i ne 1
                    {nb,cWo,((iWorkoffset-1)+i)}
                endif
                {nl,'!!copy file=' sSubspath '!!'}
                i = i + 1
            endw
            sSubspath = sCamfilepath + 'TEMPFILE' + tostr(iTcnumber:'5.0(n)')
        endif
        bFrombeginchangetool = False
    endif

;----At end of tool_change
;----Opens tempfile to print out gcode
    if bFromendchangetool eq True
        sSubspath = sCamfilepath + 'TEMPFILE' + tostr(iTcnumber:'5.0(n)')
        {nl,'!!open file=' sSubspath '!!'}
        bFromendchangetool = False
    endif

;----At end_program
;----Closes the sSubspath(tempfile) for the current tool change
;----Runs loop to print G5x and copy in the tempfile
    if bFromendprogram eq True
        {nl,'!!close file=' sSubspath '!!'}
        i = 1
        while i <= iNumber_of_Fixtures
            {nl,cCb'-----LOOPING LAST TOOL CHANGE CODE-----'cCe}
            if i ne 1
                {nb,cWo,((iWorkoffset-1)+i)}
            endif
            {nl,'!!copy file=' sSubspath '!!'}
            i = i + 1
        endw
        bFromendprogram = False
    endif

;----At eng_of_file
;----Delete all tempfiles
    if bFromendoffile eq True
        i = 1
        while i <= iTcnumber
            sSubspath = sCamfilepath + 'TEMPFILE' + tostr(i:'5.0(n)')
            {nl,'!!delete file=' sSubspath '!!'}
            i = i + 1
        endw
        bFromendoffile = false
    endif

endp

;-------------------

@usr_r1pos_calc
    ; Calculate Rotary 1 Position (Main Spindle)
    ; tmatrix + 4th Transform + cpos + 5xapos
    ; Note: Angular Feed Formula fc = f*(180/(pi*r))
    ; Note: fc=deg/min, f=linear feed
    local numeric tmpypos tmpzpos
    nR1postmatrix = (-y_angle_const_z - dev_angle_z) * iR1dir           ;Rotary from CoordSys (tmatrix)
    nR1postransform = (-angle) * iR1dir                                 ;Rotary from 4x-Transform
    nR1poscpos = (-cpos) * iR1dir                                       ;Rotary from C-axis cutting
    nR1pos5x = (-bpos) * iR1dir                                         ;Rotary from 4/5x Simulatenous
    nR1postemp = nR1postmatrix + nR1postransform + nR1poscpos + nR1pos5x
    if iR1posControl eq 0 ;SolidCAM Angles
        nR1posadj = 0
    endif
    if iR1posControl eq 1 or iR1posControl eq 3 ;Positive Angles only: Works up to 360deg
        if nR1postemp < 0 and nR1postemp > -360
            nR1posadj = 360
        else
            nR1posadj = 0
        endif
    endif
    if iR1posControl eq 2 ;Negative Angles only: Works up to 360deg
        if nR1postemp > 0 and nR1postemp < 360
            nR1posadj = -360
        else
            nR1posadj = 0
        endif
    endif
    if iR1posControl eq 3 ;Shortest Distance: Not Working yet
        if nR1postemp < 0 and nR1postemp > -360
            nR1posadj = 360
        else
            nR1posadj = 0
        endif
        if nPR1postemp ne nR1postemp
            if nPR1postemp gt nR1postemp and nR1postemp gt 0 ;and nPR1pos le 180
                nR1pdir = -1
            else
                nR1pdir = 1
            endif
        endif
    else
        nR1pdir = 1
    endif
    nR1pos = (nR1postemp + nR1posadj) * nR1pdir
    nR2postmatrix = (-x_angle_const_z) * iR2dir                        ;Rotary from CoordSys (tmatrix)
    nR2pos5x = (-apos) * iR2dir                                       ;Rotary from 4/5x Simulatenous
    nR2pos = nR2postmatrix + nR2pos5x
;    if abs(nR2pos) gt 80
;        tmpypos = ypos
;        tmpzpos = zpos
;        if change(zpos)
;            ypos = tmpzpos
;        endif
;        if change(ypos)
;            zpos = -tmpypos
;        endif
;    endif
    if nPR1pos ne nR1pos
        change(nR1pos) = TRUE
    else
        change(nR1pos) = false
    endif
    if nPR2pos ne nR2pos
        change(nR2pos) = TRUE
    else
        change(nR2pos) = false
    endif
    if bLimit_3axis
        change(nR1pos) = false
        change(nR2pos) = false
    endif
;	{nb, 'nR1postmatrix =' nR1postmatrix }
;	{nb, 'nR1postransform =' nR1postransform }
;	{nb, 'nR1poscpos =' nR1poscpos }
;	{nb, 'nR1pos5x =' nR1pos5x }
;	{nb, 'nR1postemp =' nR1postemp }
    nPR1postemp = nR1postemp
    nPR1pos = nR1pos
    nPR2pos = nR2pos

endp

@usr_4x_index
    ; Handle 4x indexing (Rotary moves between operations)
    ;4x-Indexing control (0=Simple Rotation, 1=New WorkOffset, 2=Trig Macro)
    ;4x-Index Clearance control (0=Z-Homing, 1=Z-Tool_Z_Level, 2=Z-Tool_start_plane)

    call @usr_r1pos_calc
    if change(nR1pos)
        if i4xIndexMode eq 0 ;Simple Rotation
            if i4xIndexClearanceMode eq 0
                if sHomestrrot ne ''
                    sHomestr = sHomestrrot
                    call @usr_prep_home_axis
                endif
                iMotionmode = 0
                {nb,['G'iMotionmode:mcode_f ' '],['G'iMplane' '],[cWo,iWorkoffset' '],['G'iAbsincmode ' '],[cR1,nR1pos ' ']}
            endif
            if i4xIndexClearanceMode eq 1
                if tool_z_level < tool_start_plane
                    Print 'WARNING!! Tool Z Level is below Tool Start Plane in CoordSys'
                    {nl,'WARNING!! Tool Z Level is below Tool Start Plane in CoordSys'}
                endif
                iMotionmode = 0
                {nb,['G'iMotionmode:mcode_f ' '],['G'iMplane' '],[cWo,iWorkoffset' '],['G'iAbsincmode ' '],'Z'nPtool_z_level ' '}
                {nb,['G'iMotionmode:mcode_f ' '],['G'iMplane' '],[cWo,iWorkoffset' '],['G'iAbsincmode ' '],[cR1,nR1pos ' ']}
                {nb,['G'iMotionmode:mcode_f ' '],['G'iMplane' '],[cWo,iWorkoffset' '],['G'iAbsincmode ' '],'Z'tool_z_level ' '}
            endif
            if i4xIndexClearanceMode eq 2
                iMotionmode = 0
                {nb,['G'iMotionmode:mcode_f ' '],['G'iMplane' '],[cWo,iWorkoffset' '],['G'iAbsincmode ' '],'Z'nPtool_start_plane ' '}
                {nb,['G'iMotionmode:mcode_f ' '],['G'iMplane' '],[cWo,iWorkoffset' '],['G'iAbsincmode ' '],[cR1,nR1pos ' ']}
                {nb,['G'iMotionmode:mcode_f ' '],['G'iMplane' '],[cWo,iWorkoffset' '],['G'iAbsincmode ' '],'Z'tool_start_plane ' '}
            endif
        endif
        if i4xIndexMode eq 1 ;New WorkOffset
            if i4xIndexClearanceMode eq 0
                if sHomestrrot ne ''
                    sHomestr = sHomestrrot
                    call @usr_prep_home_axis
                endif
                iMotionmode = 0
                iWorkoffset = iWorkoffset + (position-1)
                {nb,['G'iMotionmode:mcode_f ' '],['G'iMplane' '],[cWo,iWorkoffset' '],['G'iAbsincmode ' '],[cR1,nR1pos ' ']}
            endif
            if i4xIndexClearanceMode eq 1
                if tool_z_level < tool_start_plane
                    Print 'WARNING!! Tool Z Level is below Tool Start Plane in CoordSys'
                    {nl,'WARNING!! Tool Z Level is below Tool Start Plane in CoordSys'}
                endif
                iMotionmode = 0
                {nb,['G'iMotionmode:mcode_f ' '],['G'iMplane' '],[cWo,iWorkoffset' '],['G'iAbsincmode ' '],'Z'nPtool_z_level ' '}
                iWorkoffset = iWorkoffset + (position-1)
                {nb,['G'iMotionmode:mcode_f ' '],['G'iMplane' '],[cWo,iWorkoffset' '],['G'iAbsincmode ' '],[cR1,nR1pos ' ']}
                {nb,['G'iMotionmode:mcode_f ' '],['G'iMplane' '],[cWo,iWorkoffset' '],['G'iAbsincmode ' '],'Z'tool_z_level ' '}
            endif
            if i4xIndexClearanceMode eq 2
                iMotionmode = 0
                {nb,['G'iMotionmode:mcode_f ' '],['G'iMplane' '],[cWo,iWorkoffset' '],['G'iAbsincmode ' '],'Z'nPtool_start_plane ' '}
                iWorkoffset = iWorkoffset + (position-1)
                {nb,['G'iMotionmode:mcode_f ' '],['G'iMplane' '],[cWo,iWorkoffset' '],['G'iAbsincmode ' '],[cR1,nR1pos ' ']}
                {nb,['G'iMotionmode:mcode_f ' '],['G'iMplane' '],[cWo,iWorkoffset' '],['G'iAbsincmode ' '],'Z'tool_start_plane ' '}
            endif
        endif
    endif
    if i4xIndexMode eq 2 ;Trig Macro
        if sHomestrrot ne ''
            sHomestr = sHomestrrot
            call @usr_prep_home_axis
        endif
        call @usr_trig_macro_call
        iMotionmode = 0
        iWorkoffset = 112
        {nb,['G'iMotionmode:mcode_f ' '],['G'iMplane' '],[cWo,iWorkoffset' '],['G'iAbsincmode ' '],[cR1,nR1pos ' ']}
    endif
endp

@move_4x ; !@#$%
    ; Handle GPP direct call to Rapid Move (G00)
    ; We not use this procedure to output code
    ; We create our own procedure for this so that we may...
    ;   Sync with @rapid_move, @move_5x, @move_4x, @move4x_polar, @move4x_cartesian
    if change(xpos)
        xpos = 0
    endif
    call @usr_rapid
endp

@line_4x ; !@#$%
    ; Handle GPP direct call to Line Movement (G01)
    ; We not use this procedure to output code
    ; We create our own procedure for this so that we may...
    ;   Sync with @line, @line_5x, @line_4x, @line4x_polar, @line4x_cartesian
    call @usr_line
endp

@chng_tool_cnext
endp

@rotary_info
endp

@tmatrix
endp

@move_5x ; !@#$%
    ; Handle GPP direct call to Rapid Move (G00)
    ; We not use this procedure to output code
    ; We create our own procedure for this so that we may...
    ;   Sync with @rapid_move, @move_5x, @move_4x, @move4x_polar, @move4x_cartesian
    call @usr_rapid
endp

@line_5x ; !@#$%
    ; Handle GPP direct call to Line Movement (G01)
    ; We not use this procedure to output code
    ; We create our own procedure for this so that we may...
    ;   Sync with @line, @line_5x, @line_4x, @line4x_polar, @line4x_cartesian
    call @usr_line
endp

@tool_path_info
endp

@transform_info
endp

@usr_trig_macro_call
    ; Handle SubProgram call to Trig_Macro

    {nb, 'G65P777 X'shift_x ' Y'shift_y ' Z'shift_z ' C'home_number:'5.3' ' A'bpos:'5.3'  ' I0 J0 K0 '}

endp

@usr_trig_macro_output
    ; Handle Trig_Macro output (Subprogram)
    {nl}
    {nl, 'O777'}
    ;Copies Work Offset(i.e. G54) to G112 to use for Calculations
    {nb,'G103 P1'}
    {nb,'#7041= [#[5201 + 20 * #3] + #24]'} ; G112 x
    {nb,'M01'}
    {nb,'#7042= [#[5202 + 20 * #3]+ #25]'} ; G112 y
    {nb,'M01'}
    {nb,'#7043= [#[5203 + 20 * #3] + #26]'} ; G112 z
    {nb,'M01'}
    {nb,'#7044= [#[5204 + 20 * #3]]'} ; G112 A
    {nb,'M01'}
    {nb,'#7045= [#[5205 + 20 * #3]]'} ; G112 B
    {nb,'M01'} ;Stop added For HS-1RP to not read ahead

    ;Variables 7xxx are G1xx additional work offsets. Puts work offsets in a variable
    ;#7001 through #7005 = G110 X, Y, Z, A, B   (this will be the A axis Zero) X=#7001 Z=#7003
    ;#7021 through #7025 = G111 X, Y, Z, A, B   (this will be the B axis Zero) X=#7021 Z=#7022

    ;x1 = #7021
    ;y  = #7022
    ;Y2 = #7002  PICKED UP CENTER OF Y-AXIS  G110#
    ;z  = #7003  PICKED UP CENTER OF Z-AXIS  G110#

    ;Delta Changes In Y & Z- Leg of triangle used to calculate new Y & Z
    {nb,'#141= [#7042 - #7002]'} ; delta y
    {nb,'M01'}
    {nb,'#142= [#7043 - #7003]'} ; delta z
    {nb,'M01'}

    ;Trig. Formula on how to calculate offcenter parts when they rotate around the 4th axis
    ;z = z*cos(dev_angle) - y*sin(dev_angle)
    ;y = z*sin(dev_angle)  + y*cos(dev_angle)

    ;Actual Trig. Formula to Calulate the change in Z & Y in the machine
    {nb,'#148 = [[#142*COS[-#1]] - [#141*SIN[-#1]]](NEW Y B)'}  ; z
    {nb,'M01'}
    {nb,'#149 = [[#142*SIN[-#1]] + [#141*COS[-#1]]](NEW Z B)'}  ; y
    {nb,'M01'}
    {nb}

    ;New Calculated Home Position- Uses shifts from SolidCAM, Centers of machine, and calculated change in Z & Y
    {nb,'#7041 = #7041 + #4'} ; X + user shift  = new X in g112
    {nb,'M01'}
    {nb,'#7042 = #7002 + #149 + #5'} ; center Y2 + new Y calculated point + user shift  = new Y in g112
    {nb,'M01'}
    {nb,'#7043 = #7003 + #148 + #6'} ; center z  + new z calculated point + user shift  = new z in g112
    {nb,'M01'}
    {nb,'G103'}
    ;{nb,'G112'}
    ;{nb,' G0 A#1'}
    ;Used to end subprogram
    {nb,'M99'}
    {nl}
endp

@home_data
;	local integer var1 var2 Var3 var4 var5 Var6 macnum
;	local numeric newshift_z  newshift_x
;	local string shift_x_sign shift_y_sign shift_z_sign
    macnum = tonum(substr(home_user_name,(instr(home_user_name,'P') + 1),2))
    if macnum eq 0
        macnum = tonum(substr(home_user_name,(instr(home_user_name,'p') + 1),2))
    endif
    if position ne 1
        var1 = 5161 + (20 * (position + home_number))
        var2 = 5162 + (20 * (position + home_number))
        var3 = 5163 + (20 * (position + home_number))
        var4 = 7161
        var5 = 7162
        var6 = 7163
        newshift_z = shift_z*cos(-y_angle_const_z) - shift_x*sin(-y_angle_const_z)
        newshift_x = shift_z*sin(-y_angle_const_z)  + shift_x*cos(-y_angle_const_z)
        if y_angle_const_z eq 0
            newshift_b = y_angle_const_z
        else
            newshift_b = (-y_angle_const_z)
        endif
        shift_x_sign = ''
        shift_y_sign = ''
        shift_z_sign = ''
        shift_b_sign = ''
        if newshift_x < 0
            newshift_x = -1 * newshift_x
            shift_x_sign = '-'
        endif
        if shift_y < 0
            shift_y = -1 * shift_y
            shift_y_sign = '-'
        endif
        if newshift_z < 0
            newshift_z = -1 * newshift_z
            shift_z_sign = '-'
        endif
        if newshift_b < 0
            newshift_b = -1 * newshift_b
            shift_b_sign = '-'
        endif
        {nl,'$P_UIFR['(position + home_number + 2)']= CTRANS( X,'shift_x_sign,newshift_x:'5.3'}
        {', Y,'shift_y_sign,shift_y:'5.3'}
        {', Z,'shift_z_sign,newshift_z:'5.3'}
        {', B,0',')',cCb,'G',(position + home_number + 502)}
    endif
endp
